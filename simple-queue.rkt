#lang racket
(define (make-queue) (cons '() '()))
(define (queue-push q v) (cons (cons v (car q)) (cdr q)))
(define (queue-normalize q) 
   (cond ((and (null? (cdr q)) (not (null? (car q))))
          (cons '() (reverse (car q))))
         (else q)))

(define (queue-pop q)
  (let ([nq (queue-normalize q)])
    (cond ((null? (cdr nq)) (error "empty queue."))
          (else (cons (cons (car nq) (cddr nq)) (cadr nq))))))
                        
(define (queue-print q)
  (define (print-list l) 
    (cond ((null? l))
          (else (print (car l))
                (print-list (cdr l)))))
  (print-list (car q))
  (print-list (reverse (cdr q)))
  (newline))            

(define t (make-queue))      (queue-print t)
(set! t (queue-push t 1))    (queue-print t)
(set! t (queue-push t 2))    (queue-print t)
(set! t (queue-push t 3))    (queue-print t)
(set! t (car (queue-pop t))) (queue-print t) 
(set! t (queue-push t 4))    (queue-print t)
(set! t (car (queue-pop t))) (queue-print t) 
(set! t (queue-push t 5))    (queue-print t)
(set! t (car (queue-pop t))) (queue-print t)
(set! t (car (queue-pop t))) (queue-print t)
(set! t (car (queue-pop t))) (queue-print t)
(set! t (car (queue-pop t))) (queue-print t)